import java.util.zip.*

configurations {
    baselinePatch
}

//基线包路径
def host_patch_path = ""
//基线包解压路径
def host_patch_extract_dir = project.buildDir.absolutePath + '/outputs/baselinePatch'
def hostClassesJar = host_patch_extract_dir + "/host_classes.jar"

//基线包文件名
def host_patch_fileName = "host.bar"

//这一坨变量是为了支持如果插件工程本身也是分子工程时，可以在子工程中也引入这个插件脚本
def ApplicationPlugin = getPlugins().findPlugin("com.android.application")
def isApplicationModule
if (ApplicationPlugin != null) {
    isApplicationModule = true;
} else {
    isApplicationModule = false;
}
def fairyMinifyEnabled = false

android{
}

android.aaptOptions.additionalParameters(
        '-I', host_patch_extract_dir + "/" + host_patch_fileName,
        //"--stable-ids", host_patch_extract_dir + "/generated_exported_all_resouces.properties",
        '--package-id', "0x66", //默认0x7f，可以修改为任意其他值，如0x66、0x88，但要确保不和系统已经使用的id重复。典型的如0x10、0x20，都已被系统使用
        '--allow-reserved-package-id')
        
afterEvaluate {

    if (isApplicationModule) {
        if (android.defaultConfig.applicationId == null) {
            throw new Exception("插件build.gradle未配置android.defaultConfig.applicationId")
        }
    }

    configurations.each { config ->
        if (config.name.equals("baselinePatch")) {
            config.files.each { patch ->

                //读取宿主基线包文件路径
                host_patch_path = patch.absolutePath;
                println project.name + "发现宿主基线配置指向位置：" + host_patch_path

                println "检查宿主基线patch文件：" + host_patch_path

                if (!file(host_patch_path).exists()) {
                    file(host_patch_extract_dir).deleteDir();
                    println "宿主基线patch文件不存在"
                } else {
                    copy {
                        println "正在解压宿主基线patch文件：" + host_patch_path
                        def zipFile = file(host_patch_path);//host.bar
                        def outputDir = file(host_patch_extract_dir)//outputs/baselinePatch
                        outputDir.deleteDir();
                        from zipTree(zipFile)
                        from(zipFile) {
                            rename {
                                host_patch_fileName
                            }
                        }
                        into outputDir
                    }
                }

                //读取混淆开关配置
                gradle.startParameter.taskNames.each { startTaskName ->
                    if (startTaskName.startsWith("assemble")) {
                        if (startTaskName.contains("Debug")) {
                            fairyMinifyEnabled = android.buildTypes.debug.minifyEnabled
                        } else if (startTaskName.contains("Release")) {
                            fairyMinifyEnabled = android.buildTypes.release.minifyEnabled
                        }
                    }
                }

                //根据混淆开关来选择是使用compileOnly还是implementation来依赖基线包的jar
                println project.name + "添加宿主基线jar依赖：" + hostClassesJar + "\n混淆开关：minifyEnabled=" + fairyMinifyEnabled
                if (!fairyMinifyEnabled) {
                    configurations.compileOnly.dependencies.add(project.dependencies.create(files(hostClassesJar)))
                } else {
                    configurations.implementation.dependencies.add(project.dependencies.create(files(hostClassesJar)))
                }

            }
        }
    }

    def moduleVariants = isApplicationModule?android.applicationVariants:android.libraryVariants
    for (variant in moduleVariants) {

        def varName = variant.name;
        def buildTypeName = variant.buildType.name
        def flavorName = variant.flavorName
        def varDirName =  variant.dirName

        println 'Check Env : variant=' + varName +  ", buildTypeName=" + buildTypeName + ", flavorName=" + flavorName + ", varDirName=" + varDirName

        def mergeResourceTask = tasks.findByName("merge${varName.capitalize()}Resources");
        mergeResourceTask.setOnlyIf { true }
        mergeResourceTask.outputs.upToDateWhen { false }
        mergeResourceTask.doLast {
            File propFile = file(host_patch_extract_dir + "/HostInfo.prop");
            if (!propFile.exists()) {
                throw new Exception("HostInfo.prop丢失：" + propFile.absolutePath)
            }
            def Properties props = new Properties()
            props.load(new FileInputStream(propFile))
            def hostVarDirName = props.getProperty("host.varDirName")
            if (hostVarDirName == null) {
                throw new Exception("HostInfo.prop文件信息不全，请检查此文件内容：" + propFile.absolutePath)
            }
        }

        if (isApplicationModule) {
            tasks.findByName("process${varName.capitalize()}Manifest").doLast {
                File propFile = file(host_patch_extract_dir + "/HostInfo.prop");
                def hostVersionName = null
                def hostVersionCode = null
                def hostApplicationId = null
                def hostBuildType = null
                def hostFlavorName = null
                def hostVarName = null
                def hostVarDirName = null
                if (propFile.exists()) {
                    def Properties props = new Properties()
                    props.load(new FileInputStream(propFile))
                    hostVersionName = props.getProperty("host.versionName")
                    hostVersionCode = props.getProperty("host.versionCode")
                    hostBuildType = props.getProperty("host.buildType")
                    hostFlavorName = props.getProperty("host.flavorName")
                    hostVarName = props.getProperty("host.varName")
                    hostVarDirName = props.getProperty("host.varDirName")

                    hostApplicationId = props.getProperty("host.applicationId")

                    projects.logger.log(LogLevel.ERROR, "宿主基线包信息：hostVersionName=" + hostVersionName + " hostVersionCode=" + hostVersionCode + " hostApplicationId=" + hostApplicationId + " hostBuildType=" + hostBuildType + " hostFlavorName=" + hostFlavorName)

                } else {
                    throw new Exception("HostInfo.prop文件丢失，请检查此路径：" + propFile.absolutePath)
                }

                fileTree(manifestOutputDirectory).include("**/AndroidManifest.xml").each { manifestFile->
                    if (hostVersionName != null && hostApplicationId != null && hostVersionCode != null) {
                        println "插件Manifest：" + manifestFile.absolutePath
                        println "插入宿主版本号标识 requiredHostVersionName=" + hostVersionName
                        println "插入宿主版本号标识 requiredHostVersionCode=" + hostVersionCode
                        println "插入宿主ID hostApplicationId=" + hostApplicationId
                        def originManifestContent = manifestFile.getText('UTF-8')
                        def modifyedManifestContent = originManifestContent.replace("<manifest ", "<manifest requiredHostVersionName=\""
                                + hostVersionName + "\" requiredHostVersionCode=\"" + hostVersionCode
                                + "\" hostApplicationId=\"" + hostApplicationId + "\" ");
                        manifestFile.write(modifyedManifestContent, 'UTF-8')
                    } else {
                        throw new Exception("HostInfo.prop文件信息不全，请检查此文件内容：" + propFile.absolutePath)
                    }
                }
            }

            //处理混淆，这里保存混淆以后dex之前的jar包作为基线包备用
            def proguardTask = project.tasks.findByName("transformClassesAndResourcesWithProguardFor${varName.capitalize()}")

            if (proguardTask) {
                proguardTask.doFirst {
                    println "开始混淆任务 " + varName.capitalize()
                    def baselineMappingFile = host_patch_extract_dir + "/mapping/" + varName + "/mapping.txt";
                    projects.logger.log(LogLevel.ERROR, "应用基线mapping文件： " + baselineMappingFile)
                    if (!file(baselineMappingFile).exists()) {
                        throw "baselineMappingFile is Not Found : " + baselineMappingFile
                    }
                    getTransform().applyMapping(file(baselineMappingFile));
                }
                proguardTask.doLast {

                    println "混淆完成 " + varName.capitalize()

                    def host_obfuscated_jar = host_patch_extract_dir + "/host_obfuscated.jar"
                    if (!new File(host_obfuscated_jar).exists()) {
                        project.logger.error "宿主基线混淆包不存在 " + host_obfuscated_jar
                        throw new Exception("宿主基线混淆包不存在 " + host_obfuscated_jar + "， 请检查宿主编译产物中是否包含此文件")
                    }
                    println "依赖的宿主基线混淆包jar路径为：" + host_obfuscated_jar

                    boolean isFind = false;
                    outputs.files.files.each { File file->
                        //http://blog.csdn.net/sbsujjbcy/article/details/50839263
                        //build/intermediates/transforms/proguard/anzhi/release/jars/3/1f/main.jar
                        //最新版本路径已发生变化；2017-11-12
                        println "file outputs=>${file.absolutePath}"
                        String keyword = File.separator + "transforms" + File.separator + "proguard" + File.separator;
                        println "contains keyword " + keyword + " " + String.valueOf(file.absolutePath.contains(keyword)) + ", endsWith buildType " + buildTypeName + " " + String.valueOf(file.absolutePath.endsWith(buildTypeName))
                        if (file.absolutePath.contains(keyword) && file.absolutePath.endsWith(buildTypeName)) {
                            isFind = true;
                            def pluginObfuscatedJar = "plugin_obfuscated.jar"
                            def sourcePluginObfuscatedJar
                            if (new File(file.absolutePath + "/0.jar").exists()) {
                                sourcePluginObfuscatedJar = file.absolutePath + "/0.jar"
                            } else if (new File(file.absolutePath + "/jars/3/1f/main.jar").exists()) {
                                sourcePluginObfuscatedJar = file.absolutePath + "/jars/3/1f/main.jar"
                            }
                            //保留一个备份
                            project.logger.error "导出混淆后的插件jar包 "
                            println "From " + sourcePluginObfuscatedJar //此文件是proguard任务的固定输出目录，最新版文件名即是0.jar, 旧版叫main.jar
                            println "To " + "${project.buildDir}/outputs/" + pluginObfuscatedJar
                            copy {
                                from sourcePluginObfuscatedJar
                                into("${project.buildDir}/outputs/")
                                rename(new Transformer<String, String>() {
                                    @Override
                                    String transform(String s) {
                                        return pluginObfuscatedJar
                                    }
                                })
                            }

                            diffJar(sourcePluginObfuscatedJar, host_obfuscated_jar);
                        }
                    }
                    if (!isFind) {
                        throw "obfuscated jar file not found, please check."
                    }
                }
            }
        }
    }
}

def diffJar(String plugin, String host) {


    println "通过基线混淆包和插件混淆包做diff清理重复的class"

    println "插件：" + plugin + "，  宿主：" + host

    println "先把插件和宿主的都解压 " + "${project.buildDir}/tmp/jarUnzip/plugin/" + ", " + "${project.buildDir}/tmp/jarUnzip/host/"

    ZipUtil.unZip(plugin, "${project.buildDir}/tmp/jarUnzip/plugin/")
    List<String> hostClasses = ZipUtil.unZip(host, "${project.buildDir}/tmp/jarUnzip/host/")

    println "再删掉插件的源 " + plugin
    new File(plugin).delete()

    println "通过压缩过滤重新生成插件的源，替换之前被删掉的源， host classSize = " + hostClasses.size() + " " + file(plugin).getName()
    ZipUtil.zip("${project.buildDir}/tmp/jarUnzip/plugin", file(plugin).getParent(), "0.jar", hostClasses)
    println "重新生成的插件的源 " + plugin

    //备份diff后的包
    copy {
        println "备份diff后重新生成的插件的源包到插件out目录"
        println "From " + plugin
        println "To " + "${project.buildDir}/outputs/plugin_obfuscated_after_diff.jar"
        from plugin
        into("${project.buildDir}/outputs/")
        rename(new Transformer<String, String>() {
            @Override
            String transform(String s) {
                return "plugin_obfuscated_after_diff.jar"
            }
        })
    }
}

public class ZipUtil {

    public static List<String> unZip(String path, String savepath) throws IOException
    {
        def resultList = new ArrayList<String>();
        def count = -1;
        def index = -1;
        def flag = false;
        def file = null;
        def is = null;
        def fos = null;
        def bos = null;

        ZipFile zipFile = new ZipFile(path);
        Enumeration<?> entries = zipFile.entries();

        while(entries.hasMoreElements())
        {
            def buf = new byte[2048];
            ZipEntry entry = (ZipEntry)entries.nextElement();

            def filename = savepath + entry.getName();

            File folder = new File(filename).getParentFile();
            if(!folder.exists()){
                folder.mkdirs();
            }

            if(!filename.endsWith(File.separator)){

                System.out.println("解压：" + filename);

                file = new File(filename);
                file.createNewFile();
                is = zipFile.getInputStream(entry);
                fos = new FileOutputStream(file);
                bos = new BufferedOutputStream(fos, 2048);

                while((count = is.read(buf)) > -1)
                {
                    bos.write(buf, 0, count );
                }

                bos.flush();

                fos.close();
                is.close();

                resultList.add(entry.getName());
            }
        }

        zipFile.close();

        return resultList
    }

    /**
     * 递归压缩文件夹
     * @param srcRootDir 压缩文件夹根目录的子路径
     * @param file 当前递归压缩的文件或目录对象
     * @param zos 压缩文件存储对象
     * @throws Exception
     */
    public static zip(String srcRootDir, File file, ZipOutputStream zos, ArrayList<String> filter) throws Exception
    {
        if (file == null)
        {
            return;
        }

        //如果是文件，则直接压缩该文件
        if (file.isFile())
        {
            int count, bufferLen = 1024;
            byte[] data = new byte[bufferLen];

            //获取文件相对于压缩文件夹根目录的子路径
            String subPath = file.getAbsolutePath();
            int index = subPath.indexOf(srcRootDir);
            if (index != -1)
            {
                subPath = subPath.substring(srcRootDir.length() + File.separator.length());
            }

            if (filter.contains(subPath)) {
                System.out.println("过滤：" + subPath)
                return;
            } else {
                System.out.println("压缩：" + subPath)
            }

            ZipEntry entry = new ZipEntry(subPath);
            zos.putNextEntry(entry);
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
            while ((count = bis.read(data, 0, bufferLen)) != -1)
            {
                zos.write(data, 0, count);
            }
            bis.close();
            zos.closeEntry();
        }
        //如果是目录，则压缩整个目录
        else
        {
            //压缩目录中的文件或子目录
            File[] childFileList = file.listFiles();
            for (int n=0; n<childFileList.length; n++)
            {
                childFileList[n].getAbsolutePath().indexOf(file.getAbsolutePath());
                zip(srcRootDir, childFileList[n], zos, filter);
            }
        }
    }

    /**
     * 对文件或文件目录进行压缩
     * @param srcPath 要压缩的源文件路径。如果压缩一个文件，则为该文件的全路径；如果压缩一个目录，则为该目录的顶层目录路径
     * @param zipPath 压缩文件保存的路径。注意：zipPath不能是srcPath路径下的子文件夹
     * @param zipFileName 压缩文件名
     * @throws Exception
     */
    public static zip(String srcPath, String zipPath, String zipFileName, ArrayList<String> filter) throws Exception
    {
        CheckedOutputStream cos = null;
        ZipOutputStream zos = null;
        try
        {
            File srcFile = new File(srcPath);

            //判断压缩文件保存的路径是否存在，如果不存在，则创建目录
            File zipDir = new File(zipPath);
            if (!zipDir.exists() || !zipDir.isDirectory())
            {
                zipDir.mkdirs();
            }

            //创建压缩文件保存的文件对象
            String zipFilePath = zipPath + File.separator + zipFileName;
            File zipFile = new File(zipFilePath);
            if (zipFile.exists())
            {
                ///删除已存在的目标文件
                boolean success = zipFile.delete();
                System.out.println("删除已存在的目标文件:" + success)

            }

            cos = new CheckedOutputStream(new FileOutputStream(zipFile), new CRC32());
            zos = new ZipOutputStream(cos);

            //如果只是压缩一个文件，则需要截取该文件的父目录
            String srcRootDir = srcPath;
            if (srcFile.isFile())
            {
                int index = srcPath.lastIndexOf(File.separator);
                if (index != -1)
                {
                    srcRootDir = srcPath.substring(0, index);
                }
            }
            //调用递归压缩方法进行目录或文件压缩
            zip(srcRootDir, srcFile, zos, filter);
            zos.flush();
        }
        catch (Exception e)
        {
            throw e;
        }
        finally
        {
            try
            {
                if (zos != null)
                {
                    zos.close();
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}
