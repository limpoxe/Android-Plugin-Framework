import org.xml.sax.InputSource
import org.xml.sax.SAXException
import org.xml.sax.helpers.DefaultHandler

import javax.xml.parsers.ParserConfigurationException
import javax.xml.parsers.SAXParser
import javax.xml.parsers.SAXParserFactory
import javax.xml.transform.OutputKeys
import javax.xml.transform.sax.SAXTransformerFactory
import javax.xml.transform.sax.TransformerHandler
import javax.xml.transform.stream.StreamResult
import java.util.regex.Matcher
import java.util.regex.Pattern
import java.util.zip.*

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//在插件脚本中apply此脚本, 此脚本一共做了3件事
//1、编译非独立插件时引入编译宿主时导出的资源包.ap_
//2、编译非独立插件时引入编译宿主时导出的主题包
//3、扁平处理declare－style,使非独立插件支持declare－style配置
//4、修正layout文件中的自定义属性的枚举用法
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

configurations {
    baselinePatch
}

//基线包路径
def host_patch_path = ""
//基线包解压路径
def host_patch_extract_dir = project.buildDir.absolutePath + '/outputs/baselinePatch'
//基线包文件名
def host_patch_fileName = "host.bar"

//第一件事 将宿主资源添加到编译时，仅参与编译，不参与打包
android.aaptOptions.additionalParameters('-I', host_patch_extract_dir + "/" + host_patch_fileName)

HashMap<String, SortedMap<String, ArrayList<String>>> declareStyleMap = new HashMap<String, SortedMap<String, ArrayList<String>>>();

tasks.whenTaskAdded { task ->
    if (task.name.startsWith("merge") && task.name.endsWith("Resources") && !task.name.contains("AndroidTest")) {
        task.setOnlyIf { true }
        task.outputs.upToDateWhen { false }
        task.doLast {

            println "开始merge插件工程资源.."
            if (!file(host_patch_path).exists()) {
                file(host_patch_extract_dir).deleteDir();
                throw new FileNotFoundException("宿主基线patch文件不存在, 请先编译完宿主，再编译插件，并检查插件baselinePatch依赖配置是否正确: \n", host_patch_path)
            }

            copy {
                println "正在解压宿主基线patch文件..."
                def zipFile = file(host_patch_path);//host.bar
                def outputDir = file(host_patch_extract_dir)//outputs/baselinePatch
                outputDir.deleteDir();
                from zipTree(zipFile)
                from(zipFile) {
                    rename {
                        host_patch_fileName
                    }
                }
                into outputDir
            }

            //第二件事
            applyThemePatch(task.name, host_patch_extract_dir);

            //第三件事<一>
            String buildType = task.name.replace("merge", "").replace("Resources", "").toLowerCase();
            File originVaules = new File(project.buildDir, "intermediates/res/merged/" + buildType + "/values/values.xml");
            if (originVaules.exists()) {

                File valuesProcessed = new File(project.buildDir, "intermediates/res/merged/" + buildType + "/values/values_processed.xml");

                println "fixDeclareStyle " + originVaules + ", " + valuesProcessed.absolutePath

                StyleProcessor styleProcessor = StyleProcessor.fixDeclareStyle(originVaules, valuesProcessed);

                SortedMap<String, ArrayList<String>> map = styleProcessor.attrList;
                if (map != null) {
                    declareStyleMap.put(buildType, map)
                }
                originVaules.delete()

                //第四件事，修正layout文件中的自定义属性的枚举用法
                File resDir = new File(project.buildDir, "intermediates/res/merged/" + buildType);
                resDir.eachFileRecurse({file ->
                    if (file.absolutePath.contains("/layout") && file.name.endsWith(".xml")) {
                        String fileText = file.text;
                        Iterator<Map.Entry<String, String>> itr = styleProcessor.enumItemList.iterator();
                        println "try fix enum attr for " + file.absolutePath
                        while(itr.hasNext()) {
                            Map.Entry<String, String> entryItem = itr.next();
                            fileText = fileText.replaceAll(entryItem.key, entryItem.value)
                        }

                        println "try fix flag attr for " + file.absolutePath
                        fileText = StyleProcessor.fixAttrFlag(fileText, styleProcessor.attrFlagMap);

                        file.write(fileText);
                    }
                }
                )
            }
        }
    } else if (task.name.startsWith("generate") && task.name.endsWith("Sources")) {
        task.doLast {
            //第三件事<二>
            //处理R文件，生成decalre-style
            String buildType = task.name.replace("generate", "").replace("Sources", "").toLowerCase()

            FileTree rfiles = fileTree(dir: project.buildDir.absolutePath + "/generated/source/r/"+ buildType, include: ['**/R.java'])
            rfiles.each { File itemFile ->

                File newR = new File(itemFile.getAbsolutePath()+ "_temp");
                File originR = itemFile;

                println "fix R.java, \n" + newR.absolutePath + ", \n" + originR.absolutePath

                newR.delete()
                SortedMap<String, ArrayList<String>> map = declareStyleMap.get(buildType);

                if (originR.exists() && map != null) {
                    BufferedReader br = new BufferedReader(new FileReader(originR));
                    BufferedWriter bw = new BufferedWriter(new FileWriter(newR));
                    String srcLine = null;
                    boolean hasStyleable = false;
                    while((srcLine = br.readLine()) != null) {
                        if (srcLine.equals("public final class R {")) {
                            bw.writeLine(srcLine);

                            bw.writeLine("  public static final class styleable {");
                            Iterator<Map.Entry<String, ArrayList<String>>> itr = map.iterator();
                            while(itr.hasNext()) {
                                Map.Entry<String, ArrayList<String>> item = itr.next();
                                String key = item.key;
                                StringBuilder sb = new StringBuilder();
                                for(int i = 0; i < item.value.size(); i++) {
                                    bw.writeLine("      public static int " + key + "_" + item.value.get(i) + "=" + i + ";");
                                    sb.append(android.defaultConfig.applicationId).append(".R.attr.").append(item.value.get(i)).append(",")
                                }
                                if (sb.length() > 0) {
                                    sb.deleteCharAt(sb.length()-1)
                                }
                                bw.writeLine("      public static int[] " + key + " = {" + sb.toString() + "};");
                            }
                            bw.writeLine("  }")
                        } else if (srcLine.contains("public static final class styleable {")) {
                            hasStyleable = true;
                        } else if (hasStyleable && srcLine.trim().equals("}")) {
                            hasStyleable = false;
                        } else {
                            bw.writeLine(srcLine);
                        }
                    }
                    bw.close()
                    br.close()

                    originR.delete()
                    newR.renameTo(originR)
                }
            }
        }
    }
}

afterEvaluate {

    configurations.each { config ->
        if (config.name.equals("baselinePatch")) {
            config.files.each { patch ->

                host_patch_path = patch.absolutePath;
                println project.name + "发现宿主基线配置指向位置：" + host_patch_path

                def fairyMinifyEnabled = false;
                gradle.startParameter.taskNames.each { startTaskName ->
                    if (startTaskName.startsWith("assemble")) {
                        if (startTaskName.contains("Debug")) {
                            fairyMinifyEnabled = android.buildTypes.debug.minifyEnabled
                        } else if (startTaskName.contains("Release")) {
                            fairyMinifyEnabled = android.buildTypes.release.minifyEnabled
                        }
                    }
                }

                String hostClasses = host_patch_extract_dir + "/host_classes.jar"
                println project.name + "添加宿主基线jar依赖：" + hostClasses + "\n混淆开关：minifyEnabled=" + fairyMinifyEnabled
                //根据混淆开关来选择是使用compileOnly还是implementation来依赖基线包的jar
                if (!fairyMinifyEnabled) {
                    configurations.compileOnly.dependencies.add(project.dependencies.create(files(hostClasses)))
                } else {
                    configurations.implementation.dependencies.add(project.dependencies.create(files(hostClasses)))
                }
            }
        }
    }

    for (variant in android.applicationVariants) {

        //println variant.buildType.minifyEnabled

        for (baseVariant in variant.outputs) {

            baseVariant.processResources.doFirst {
                println "开始处理插件工程资源.."
                if (!new File(host_patch_path).exists()) {
                    throw new FileNotFoundException("宿主基线patch文件不存在, 请先编译完宿主，再编译插件，并检查插件baselinePatch依赖配置是否正确: \n", host_patch_path)
                }
                if (!file(host_patch_extract_dir).exists()) {
                    throw new FileNotFoundException("宿主基线patch文件不存在, 请先编译完宿主，再编译插件，并检查插件baselinePatch依赖配置是否正确: \n", host_patch_extract_dir)
                }
            }

            baseVariant.processManifest.doLast {
                File propFile = file(host_patch_extract_dir + "/HostInfo.prop");
                def hostVersionName = null;
                if (propFile.exists()) {
                    def Properties props = new Properties()
                    props.load(new FileInputStream(propFile))
                    hostVersionName = props.getProperty("host.versionName")
                }
                if (hostVersionName != null) {
                    println "插件Manifest文件中插入宿主版本号标识 requiredHostVersionName=" + hostVersionName
                    File manifestFile = new File("$manifestOutputDirectory/AndroidManifest.xml")
                    println "插件Manifest：" + manifestFile.absolutePath
                    def originManifestContent = manifestFile.getText('UTF-8')
                    def modifyedManifestContent = originManifestContent.replace("<manifest ", "<manifest requiredHostVersionName=\"" + hostVersionName + "\" ");
                    manifestFile.write(modifyedManifestContent, 'UTF-8')
                }
            }
        }

        //处理混淆，这里保存混淆以后dex之前的jar包作为基线包备用
        def proguardTask = project.tasks.findByName("transformClassesAndResourcesWithProguardFor${variant.name.capitalize()}")
        def String buildType = variant.buildType.name
        def variantName = variant.name
        //println variant.name + " " + variant.buildType.name
        if (proguardTask) {
            proguardTask.doFirst {
                println "开始混淆任务 " + variantName.capitalize()
                def baselineMappingFile = host_patch_extract_dir + "/mapping/" + variantName + "/mapping.txt";
                println "应用基线mapping文件： " + baselineMappingFile
                if (!file(baselineMappingFile).exists()) {
                    throw "baselineMappingFile is Not Found : " + baselineMappingFile
                }
                getTransform().applyMapping(file(baselineMappingFile));
            }
            proguardTask.doLast {

                println "混淆完成 " + variantName.capitalize()

                def host_obfuscated_jar = host_patch_extract_dir + "/host_" + variantName.capitalize() + "_obfuscated.jar"
                if (!new File(host_obfuscated_jar).exists()) {
                    project.logger.error "宿主基线混淆包不存在 " + host_obfuscated_jar
                    throw new Exception("宿主基线混淆包不存在 " + host_obfuscated_jar + "， 请检查宿主编译产物中是否包含此文件")
                }
                println "依赖的宿主基线混淆包jar路径为：" + host_obfuscated_jar

                boolean isFind = false;
                proguardTask.outputs.files.files.each { File file->
                    //http://blog.csdn.net/sbsujjbcy/article/details/50839263
                    //build/intermediates/transforms/proguard/anzhi/release/jars/3/1f/main.jar
                    //最新版本路径已发生变化；2017-11-12
                    println "file outputs=>${file.absolutePath}"
                    String keyword = File.separator + "transforms" + File.separator + "proguard" + File.separator;
                    println "contains keyword " + keyword + " " + String.valueOf(file.absolutePath.contains(keyword)) + ", endsWith buildType " + buildType + " " + String.valueOf(file.absolutePath.endsWith(buildType))
                    if (file.absolutePath.contains(keyword) && file.absolutePath.endsWith(buildType)) {
                        isFind = true;
                        //保留一个备份
                        println "导出混淆后的插件jar包 "
                        println "From " + file.absolutePath + "/0.jar" //此文件是proguard任务的固定输出目录，最新版文件名即是0.jar, 旧版叫main.jar
                        println "To " + "${project.buildDir}/outputs/" + "plugin_" + variantName + "_obfuscated.jar"
                        copy {
                            from file.absolutePath + "/0.jar"
                            into("${project.buildDir}/outputs/")
                            rename('0', "plugin_" + variantName + "_obfuscated")
                        }

                        diffJar(file.absolutePath + "/0.jar", host_obfuscated_jar, "plugin_" + variantName + "_obfuscated");
                    }
                }
                if (!isFind) {
                    throw "obfuscated jar file not found, please check."
                }

            }
        }
    }
}

def diffJar(String plugin, String host, String name) {


    println "通过基线混淆包和插件混淆包做diff清理重复的class"

    println "插件：" + plugin + "，  宿主：" + host

    println "先把插件和宿主的都解压 " + "${project.buildDir}/tmp/jarUnzip/plugin/" + ", " + "${project.buildDir}/tmp/jarUnzip/host/"

    ZipUtil.unZip(plugin, "${project.buildDir}/tmp/jarUnzip/plugin/")
    List<String> hostClasses = ZipUtil.unZip(host, "${project.buildDir}/tmp/jarUnzip/host/")

    println "再删掉插件的源 " + plugin
    new File(plugin).delete()

    println "通过压缩过滤重新生成插件的源，替换之前被删掉的源， host classSize = " + hostClasses.size() + " " + file(plugin).getName()
    ZipUtil.zip("${project.buildDir}/tmp/jarUnzip/plugin", file(plugin).getParent(), "0.jar", hostClasses)
    println "重新生成的插件的源 " + plugin

    //备份diff后的包
    copy {
        println "备份diff后重新生成的插件的源包到插件out目录"
        println "From " + plugin
        println "To " + "${project.buildDir}/outputs/" + name + "_after_diff.jar"
        from plugin
        into("${project.buildDir}/outputs/")
        rename("0", name + "_after_diff")
    }
}

public class ZipUtil {

    public static List<String> unZip(String path, String savepath) throws IOException
    {
        def resultList = new ArrayList<String>();
        def count = -1;
        def index = -1;
        def flag = false;
        def file = null;
        def is = null;
        def fos = null;
        def bos = null;

        ZipFile zipFile = new ZipFile(path);
        Enumeration<?> entries = zipFile.entries();

        while(entries.hasMoreElements())
        {
            def buf = new byte[2048];
            ZipEntry entry = (ZipEntry)entries.nextElement();

            def filename = savepath + entry.getName();

            File folder = new File(filename).getParentFile();
            if(!folder.exists()){
                folder.mkdirs();
            }

            if(!filename.endsWith(File.separator)){

                System.out.println("解压：" + filename);

                file = new File(filename);
                file.createNewFile();
                is = zipFile.getInputStream(entry);
                fos = new FileOutputStream(file);
                bos = new BufferedOutputStream(fos, 2048);

                while((count = is.read(buf)) > -1)
                {
                    bos.write(buf, 0, count );
                }

                bos.flush();

                fos.close();
                is.close();

                resultList.add(entry.getName());
            }
        }

        zipFile.close();

        return resultList
    }

    /**
     * 递归压缩文件夹
     * @param srcRootDir 压缩文件夹根目录的子路径
     * @param file 当前递归压缩的文件或目录对象
     * @param zos 压缩文件存储对象
     * @throws Exception
     */
    public static zip(String srcRootDir, File file, ZipOutputStream zos, ArrayList<String> filter) throws Exception
    {
        if (file == null)
        {
            return;
        }

        //如果是文件，则直接压缩该文件
        if (file.isFile())
        {
            int count, bufferLen = 1024;
            byte[] data = new byte[bufferLen];

            //获取文件相对于压缩文件夹根目录的子路径
            String subPath = file.getAbsolutePath();
            int index = subPath.indexOf(srcRootDir);
            if (index != -1)
            {
                subPath = subPath.substring(srcRootDir.length() + File.separator.length());
            }

            if (filter.contains(subPath)) {
                System.out.println("过滤：" + subPath)
                return;
            } else {
                System.out.println("压缩：" + subPath)
            }

            ZipEntry entry = new ZipEntry(subPath);
            zos.putNextEntry(entry);
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
            while ((count = bis.read(data, 0, bufferLen)) != -1)
            {
                zos.write(data, 0, count);
            }
            bis.close();
            zos.closeEntry();
        }
        //如果是目录，则压缩整个目录
        else
        {
            //压缩目录中的文件或子目录
            File[] childFileList = file.listFiles();
            for (int n=0; n<childFileList.length; n++)
            {
                childFileList[n].getAbsolutePath().indexOf(file.getAbsolutePath());
                zip(srcRootDir, childFileList[n], zos, filter);
            }
        }
    }

    /**
     * 对文件或文件目录进行压缩
     * @param srcPath 要压缩的源文件路径。如果压缩一个文件，则为该文件的全路径；如果压缩一个目录，则为该目录的顶层目录路径
     * @param zipPath 压缩文件保存的路径。注意：zipPath不能是srcPath路径下的子文件夹
     * @param zipFileName 压缩文件名
     * @throws Exception
     */
    public static zip(String srcPath, String zipPath, String zipFileName, ArrayList<String> filter) throws Exception
    {
        CheckedOutputStream cos = null;
        ZipOutputStream zos = null;
        try
        {
            File srcFile = new File(srcPath);

            //判断压缩文件保存的路径是否存在，如果不存在，则创建目录
            File zipDir = new File(zipPath);
            if (!zipDir.exists() || !zipDir.isDirectory())
            {
                zipDir.mkdirs();
            }

            //创建压缩文件保存的文件对象
            String zipFilePath = zipPath + File.separator + zipFileName;
            File zipFile = new File(zipFilePath);
            if (zipFile.exists())
            {
                ///删除已存在的目标文件
                boolean success = zipFile.delete();
                System.out.println("删除已存在的目标文件:" + success)

            }

            cos = new CheckedOutputStream(new FileOutputStream(zipFile), new CRC32());
            zos = new ZipOutputStream(cos);

            //如果只是压缩一个文件，则需要截取该文件的父目录
            String srcRootDir = srcPath;
            if (srcFile.isFile())
            {
                int index = srcPath.lastIndexOf(File.separator);
                if (index != -1)
                {
                    srcRootDir = srcPath.substring(0, index);
                }
            }
            //调用递归压缩方法进行目录或文件压缩
            zip(srcRootDir, srcFile, zos, filter);
            zos.flush();
        }
        catch (Exception e)
        {
            throw e;
        }
        finally
        {
            try
            {
                if (zos != null)
                {
                    zos.close();
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}

def applyThemePatch(taskName, hostPatchExtractDir) {

    def buildType = taskName.replace("merge", "").replace("Resources", "").toLowerCase();
    def fromDir = hostPatchExtractDir + "/theme_patch/" + buildType;
    def resourceDir = project.buildDir.absolutePath + "/intermediates/res/merged/" + buildType;

    FileTree allxmlFiles = fileTree(dir: fromDir)
    allxmlFiles.include '*.xml'

    if (allxmlFiles.size() == 0) {
        println "theme_patch目录未生成，请先编译宿主！！"
        throw new FileNotFoundException("theme_patch目录未生成，请先编译宿主！！\n请检查这个目录：\n" + fromDir);
    }

    allxmlFiles.each { File itemFile ->

        String dest;
        if (itemFile.name.equals('patch_theme.xml')) {
            dest = resourceDir +  '/values/'
        } else {
            dest = resourceDir +  '/' + itemFile.name.replace('patch_', '').replace('.xml', '')  + "/"
        }

        println "apply from " + itemFile + " to " + dest
        copy {
            from(fromDir) {
                include itemFile.name
            }
            into(dest)
        }
    }
}

/** fix provided config for aar dependences
ext.plist = []
configurations.provided.dependencies.each {dep ->
    println dep
    gradle.startParameter.taskNames.each { startTaskName ->
        if (startTaskName.startsWith("assemble") || startTaskName.startsWith("build")) {
            if (dep.version.equals('unspecified')) {

                String buildType = startTaskName.replace("assemble", "").replace("build", "")
                if (buildType.length() == 0) {
                    buildType = "debug";
                }

                //为依赖库插入jar任务
                dep.dependencyProject.tasks.getByName("compile" + buildType + "Sources").doLast {
                    String jarTaskName = "jar" + buildType.substring(0, 1).toUpperCase()+ buildType.replaceFirst("\\w","") +  "Classes"
                    println '执行task：' + jarTaskName;
                    dep.dependencyProject.tasks.getByName(jarTaskName).execute()
                }

                //src的jar
                File srcJar = new File(dep.dependencyProject.buildDir, "intermediates/packaged/" + buildType + "/classes.jar")
                addProvidedDependences(configurations.provided.dependencies, srcJar);

                //处理aar依赖
                File aarDir = new File(dep.dependencyProject.buildDir, "intermediates/exploded-aar")
                addProvidedDependences(configurations.provided.dependencies, aarDir)

                //处理libs/jar依赖
                //TODO

            }
        }
    }
}

configurations.provided.dependencies.clear()

ext.plist.each { path ->
    configurations.provided.dependencies.add(project.dependencies.create(files(path)))
    println "try add provided jar to plugin project : " + path
}

def addProvidedDependences(DependencySet providedDepSet, File root) {
    //宿主编译前文件可能不存在, 所以要先编译宿主 再编译插件
    if (root.getName().endsWith(".jar")) {
        ext.plist +=[root.getAbsolutePath()]
        //providedDepSet.add(project.dependencies.create(files(root.getAbsolutePath())))
        //println "try add provided jar to plugin project : " + root.getAbsolutePath()
    } else {
        File[] subFiles = root.listFiles();
        if (subFiles != null) {
            for (File subFile : subFiles) {
                addProvidedDependences(providedDepSet, subFile);
            }
        }
    }
}
*/


public class StyleProcessor extends DefaultHandler {

    File destFile;
    Stack<Node> stack = new Stack<Node>();
    TransformerHandler outXmlHandler;

    SortedMap<String, ArrayList<String>> attrList = new TreeMap<String, ArrayList<String>>();
    HashSet<String> attrSets = new HashSet<String>();

    HashMap<String, String> enumItemList = new HashMap<String, String>();

    HashMap<String, HashMap<String, String>> attrFlagMap = new HashMap<String, HashMap<String, String>>();

    public StyleProcessor(File destFile) {
        this.destFile = destFile;

        SAXTransformerFactory factory = (SAXTransformerFactory)SAXTransformerFactory.newInstance();
        outXmlHandler = factory.newTransformerHandler();

    }

    public static StyleProcessor fixDeclareStyle(File srcFile, File destFile) {
        try {
            SAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();
            StyleProcessor processor = new StyleProcessor(destFile);
            BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(srcFile), "UTF-8"));
            InputSource inputSource = new InputSource(br)
            saxParser.parse(inputSource, processor);
            return processor;
        } catch (ParserConfigurationException e) {
            System.out.println(e.getMessage());
        } catch (SAXException e) {
            System.out.println(e.getMessage());
        } catch (FileNotFoundException e) {
            System.out.println(e.getMessage());
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
        return null;
    }

    ////////////////
    ////////////////
    ////////////////

    public void startDocument() throws SAXException {
        try {
            javax.xml.transform.Transformer transformer = outXmlHandler.getTransformer();     // 设置xml属性
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.setOutputProperty(OutputKeys.ENCODING, "utf-8");
            transformer.setOutputProperty(OutputKeys.VERSION, "1.0");
            outXmlHandler.setResult(new StreamResult(new OutputStreamWriter(new FileOutputStream(destFile), "UTF-8")));
            char[] common = new String("\n AUTO-GENERATED FILE.  DO NOT MODIFY \n").toCharArray();
            outXmlHandler.comment(common, 0, common.length);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void startElement(String uri, String localName, String qName, org.xml.sax.Attributes attributes) throws SAXException {

        boolean skip = false;
        if (!qName.equals("declare-styleable")) {
            String space = "\n";
            for (int i = 0; i < stack.size(); i++) {
                space = space + "    ";
            }
            String tag = space + "<" + qName;
            for (int i = 0; i < attributes.getLength(); i++) {
                tag = tag + " " + attributes.getQName(i) + "=\""+ attributes.getValue(i) + "\"";
            }
            tag = tag + ">";

            if (qName.equals("attr") && stack.size() == 2) {
                String parentDecalreStyleName = attrList.lastKey();
                attrList.get(parentDecalreStyleName).add(attributes.getValue("name"));
            }

            if (qName.equals("enum") && stack.size() == 3) {

                Node n3 = stack.get(2);
                String attr = n3.name;

                String regx = ":" + attr + "\\s*=\\s*\"" + attributes.getValue("name") + "\"";
                String regValue = ":" + attr + "=\"" + attributes.getValue("value") + "\"";
                println "prepare enum att regx " + regx + "-->" + regValue + " enumItemList size = " + enumItemList.size();
                enumItemList.put(regx, regValue)

            }

            if (qName.endsWith("flag") && stack.size() == 3) {

                Node n3 = stack.get(2);
                String attr = n3.name;

                String flagName = attributes.getValue("name");
                String flagValue = attributes.getValue("value");

                HashMap<String, String> item = attrFlagMap.get(attr);
                if (item == null) {
                    item = new HashMap<String, String>();
                    attrFlagMap.put(attr, item)
                }

                println "collect attr flag " + attr + "={" + flagName + "=" + flagValue + "}"

                item.put(flagName, flagValue);
            }

            if (qName.equals("attr")) {
                if (!attrSets.contains(attributes.getValue("name"))) {
                    attrSets.add(attributes.getValue("name"));
                    try {
                        outXmlHandler.startElement(uri, localName, qName, attributes)
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                } else {
                    skip = true;
                }
            } else {
                try {
                    outXmlHandler.startElement(uri, localName, qName, attributes)
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        } else {
            //declare-styleable的name属性
            attrList.put(attributes.getValue("name"), new ArrayList<String>());
        }

        if (!stack.empty()) {
            Node top = stack.peek();
            top.hasChild = true;
        }
        stack.add(new Node(attributes.getValue("name"), false, skip));
    }

    public void endElement(String uri, String localName, String qName) throws SAXException {

        Node node = stack.pop();
        if (node.skip) {
            return;
        }

        if (!qName.equals("declare-styleable")) {
            String space = "";
            if (node.hasChild) {
                space = "\n";
                for (int i = 0; i < stack.size(); i++) {
                    space = space + "    ";
                }
            }
            try {
                outXmlHandler.endElement(uri, localName, qName)
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        Node node = stack.peek();
        if (node.skip) {
            return;
        }

        try {
            outXmlHandler.characters(ch, start, length)
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public void endDocument() throws SAXException {
        try {
            outXmlHandler.endDocument();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static class Node {
        String name = null;
        boolean hasChild = false;
        boolean skip = false;

        public Node(String name, boolean hasChild, boolean skip) {
            this.name = name;
            this.hasChild = hasChild;
            this.skip = skip;
        }
    }

    public static String fixAttrFlag(final String xmlText, HashMap<String, HashMap<String, String>> attrFlagMap) {

        String localText = xmlText;

        Iterator<Map.Entry<String, HashMap<String, String>>> flagItr = attrFlagMap.entrySet().iterator();

        while (flagItr.hasNext()) {
            Map.Entry<String, HashMap<String, String>> entry = flagItr.next();

            HashMap<String, String> flagValueMap = entry.getValue();
            String attrName = entry.getKey();

            String regx = ":" + attrName + "\\s*=\\s*\".+?\"";

            Matcher matcher = Pattern.compile(regx).matcher(localText);

            HashMap<String, String> flagsMap = new HashMap<String, String>();

            while(matcher.find()) {

                String text0 = matcher.group(0);

                String flagValue = text0.split("=")[1].trim().replaceAll("\"", "");
                String[] flags = flagValue.split("\\|");

                Integer flagIntValue = null;
                for(String flag: flags) {

                    String intFlag = flagValueMap.get(flag);
                    int definedValue;
                    if (intFlag.startsWith("0x")) {
                        //16进制
                        definedValue = Integer.valueOf(intFlag.substring(2), 16);
                    } else {
                        //10进制
                        definedValue = Integer.valueOf(intFlag);
                    }

                    if (flagIntValue == null) {
                        flagIntValue = definedValue;
                    } else {
                        flagIntValue = flagIntValue | definedValue;
                    }
                }

                String text0ed = ":" + attrName + "=\"" + flagIntValue + "\"";
                text0 = text0.replaceAll("\\|", "\\\\|");//正则转义

                println "prepare enum att regx " + attrName + ", " + text0 + " --> " + text0ed

                flagsMap.put(text0, text0ed);
            }

            Iterator<Map.Entry<String, String>> iterator = flagsMap.entrySet().iterator();
            while(iterator.hasNext()) {
                Map.Entry<String, String> stringEntry = iterator.next();
                localText = localText.replaceAll(stringEntry.getKey(), stringEntry.getValue());
            }
        }

        return localText;
    }

}